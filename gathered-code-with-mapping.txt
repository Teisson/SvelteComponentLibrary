
// === CODE SECTION ===


// File: src/routes/+page.svelte

<h1>Welcome to SvelteKit</h1> <p>  Visit <a href="https:  </p> 

// File: src/routes/api/sign/+server.ts

import { error } from '@sveltejs/kit'; import type { RequestHandler } from './$types'; import { getSessionData } from '$lib/sessionHandler'; export const POST: RequestHandler = async ({ request }) => {  const { message, signature } = await request.json();     console.log('Message:', message);  console.log('Signature:', signature);     let msg = message.split('$');  let usernames = msg[0].split('#');  let account = msg[1]     console.log('Usersnames:', usernames);  console.log('Account:', account);  const cookieHeader = request.headers.get('cookie') || '';  const cookies = Object.fromEntries(  cookieHeader.split('; ').map((c) => c.split('=').map(decodeURIComponent))  );  const sessionID = cookies['session_id'];  console.log('SessionID', sessionID);  let sessionData = getSessionData(sessionID);                 return new Response(JSON.stringify({ success: true }), {  headers: { 'Content-Type': 'application/json' }  }); } 

// File: src/routes/api/validate/+server.ts

import { error } from '@sveltejs/kit'; import type { RequestHandler } from './$types'; import { getSessionData } from '$lib/sessionHandler'; import { isAccountUnique, isDiscordUnique, isTwitterUnique } from '$lib/databaseHandler'; export const GET: RequestHandler = async ({ request, url, params }) => {     const urlParams = new URLSearchParams(url.search);  let param = urlParams.get('message');  if (!param) {  return error(400, 'Message parameter is missing');  }  const [user1, rest] = param.split(':');  if (!rest) {  return error(400, 'Message format is incorrect: missing :');  }  const [user2, account] = rest.split(';');  if (!account) {  return error(400, 'Message format is incorrect: missing ; or account');  }  let discordIsUnique = await isDiscordUnique(user1);  let twitterIsUnique = await isTwitterUnique(user2);  let accountIsUnique = await isAccountUnique(account);  let validation = {  discordIsUnique: discordIsUnique,  twitterIsUnique: twitterIsUnique,  accountIsUnique: accountIsUnique  }  if (!discordIsUnique) {  return error(400, 'Discord username is not unique');  }  if (!twitterIsUnique) {  return error(400, 'Twitter username is not unique');  }  if (!accountIsUnique) {  return error(400, 'Account is not unique');  }     return new Response(JSON.stringify({ ...validation }), {  status: 200,  headers: { 'Content-Type': 'application/json' }  }); }

// File: src/routes/register/+page.server.ts

import type { PageServerLoad } from './$types'; import { updateSessionData, getSessionData, createSession, cookieOptions } from '$lib/sessionHandler' import { error } from '@sveltejs/kit' import { getTwitterRedirectUrl } from '$lib/twitterAuth'; export const load = (async ({ params, locals, cookies }) => {  let sessionID = cookies.get('sessionID') as string | undefined;  let session_id = cookies.get('session_id') as string | undefined;  let sessionData = null  let twitterRedirectURL;  if (!sessionID) {  let { sessionID } = await createSession(cookies)  if (sessionID) {  twitterRedirectURL = getTwitterRedirectUrl(sessionID);  }  }  if (sessionID) twitterRedirectURL = getTwitterRedirectUrl(sessionID)  if (session_id && sessionID) {  try {  cookies.set('session_id', session_id, cookieOptions)  cookies.set('sessionID', sessionID, cookieOptions)  sessionData = await getSessionData(sessionID)  }  catch (e) {  console.log('e:', e)  }  }  if (sessionData?.twitter && sessionData?.discord && sessionID) updateSessionData(sessionID, { stage: "authenticated" })  return {  ...sessionData,  twitterRedirectURL  }; }) satisfies PageServerLoad;

// File: src/routes/register/+page.svelte

<script lang="ts">  export let data;  import { JsonView } from "@zerodevx/svelte-json-view";  import { walletStore, signMessage } from "$lib/wallet";  const json = { ...data };  const redirectTwitterUrl = json.twitterRedirectURL;  let twitter = json?.twitter;  let discordUsername = json.discord?.username;  let stage = json.stage;  let message = "";  async function sign() {  let invalid = fetch("api/validate?message=" + message)  .then((res) => res.json())  .then((data) => {  console.log(data);  });  const signature = await signMessage(walletStore.config, { message });  let response = await fetch("/api/sign", {  method: "POST",  headers: {  "Content-Type": "application/json",  },  body: JSON.stringify({  signature,  message,  }),  });  let data = await response.json();  if (data.success) {  window.location.href = "/";  }  }  $: message =  discordUsername +  ":" +  twitter?.userData?.data.username +  ";" +  $walletStore.address; </script> <h1>register</h1> {#if discordUsername}  <p>Discord Authenticated - {discordUsername}</p> {/if} {#if !discordUsername}  <a  href="https:   >discord authentication</a  > {/if} {#if twitter}  <p>  Twitter Authenticated -  {twitter?.userData?.data.username}  </p> {/if} {#if !twitter}  <a href={redirectTwitterUrl}>X authentication</a> {/if} {#if stage === "authenticated"}  {#if $walletStore.isConnected}  <p>Connected</p>  <div>  <p>Address: {$walletStore.address}</p>  <p>Connected on: {$walletStore.chain?.name}</p>  <button on:click={sign}>Sign to register</button>  </div>  {:else}  <button on:click={walletStore.connect}> Connect wallet </button>  {/if} {/if} {#if json}  <JsonView {json}></JsonView> {/if} 

// File: src/routes/register/discordResponse/+page.server.ts

import { getDiscordAuth, discordError } from '$lib/discordAuth'; import { redirect } from '@sveltejs/kit'; import type { PageServerLoad } from './$types'; import { updateSessionData } from '$lib/sessionHandler' interface DiscordUser {  [key: string]: any;    } import type { SessionData } from '$lib/sessionHandler'; export const load = (async ({ url, cookies }) => {  let code = url.searchParams.get("code");  console.log('discord:code:' + code)  let _idcookie = cookies.get('session_id')  console.log('sessioncookie:' + _idcookie)  if (!_idcookie) return { error: "no _id cookie present, invalid session." }     if (!code) {  console.log('session-error: !code')  return { error: "No authorization code provided" };  }     let discordUserResponse = await getDiscordAuth(code);     if (discordUserResponse.error) {  discordError(discordUserResponse)  }     const discordUser = discordUserResponse.user as DiscordUser;  let sessionID = cookies.get('sessionID') as string | undefined;  let session_id = cookies.get('session_id') as string | undefined;     if (discordUser?.username && sessionID) {  updateSessionData(sessionID, { discord: discordUser })  redirect(301, '/register')  } }) satisfies PageServerLoad;

// File: src/routes/register/discordResponse/+page.svelte

<script lang="ts">  export let data;  import { goto } from "$app/navigation";  import { browser } from "$app/environment";                       const json = { foo: "bar" }; </script> {#if data?.discordUser}  <p>User has authenticated discord</p> {:else}  <p>No authentication present, you will be redirected in 4 seconds.</p>  {JSON.stringify(data)}  <a  href="https:   >authenticate discord</a  > {/if} {#if data.error}  <p>Error: {data.error}</p>  <p>Status: {data.status}</p>  <p>Detail: {data.detail}</p> {/if} 

// File: src/routes/register/twitter/+page.server.ts

  import { updateSessionData } from '$lib/sessionHandler'; import type { PageServerLoad } from './$types'; import { redirect } from '@sveltejs/kit'; import { handleTwitterCallback } from '$lib/twitterAuth' export const load = (async ({ url, params, cookies }) => {  let sessionID = cookies.get('sessionID')  let session_id = cookies.get('session_id')  if (sessionID && session_id) {  let code = url.searchParams.get('code')  let state = url.searchParams.get('state')  if (state === sessionID && code) {  let user = await handleTwitterCallback(state, code, sessionID)  console.log('/twitter:user', user)  updateSessionData(sessionID, { twitter: user })  redirect(301, '/register')  }  }  redirect(300, '/register') }) as PageServerLoad; 

// File: src/routes/register/twitter/+page.svelte

<script lang="ts">  export let data; </script> <h3>hello TwitterResponse</h3> {#if data}  {JSON.stringify(data)} {/if} 

// File: src/lib/config.ts

import { http, createConfig } from '@wagmi/core' import { mainnet, sepolia } from '@wagmi/core/chains' const chains = [mainnet, sepolia] as const; export const config = createConfig({  chains: chains,  transports: {  [mainnet.id]: http(),  [sepolia.id]: http(),  }, })

// File: src/lib/databaseHandler.ts

import { db } from '../hooks.server.js' export async function isDiscordUnique(username: string): Promise<boolean> {  const unique = await db.collection('_users').distinct('discord');  if (!unique) return false;  return !unique.includes(username); } export async function isTwitterUnique(username: string): Promise<boolean> {  const unique = await db.collection('_users').distinct('twitter');  if (!unique) return false;  return !unique.includes(username); } export async function isAccountUnique(username: string): Promise<boolean> {  const unique = await db.collection('_users').distinct('account');  if (!unique) return false;  return !unique.includes(username); } 

// File: src/lib/discordAuth.ts

import { DISCORD_AUTH, DISCORD_ID } from "$env/static/private" let auth = DISCORD_AUTH; let id = DISCORD_ID; interface IJsonResponse {  access_token: string; } interface IUserResponse {  user: object; } async function wrongAnswer(discordResponse: Response) {  const errorDetail = await discordResponse.text();  return {  error: "Failed to fetch access token",  status: discordResponse.status,  detail: errorDetail,  }; } export async function getDiscordAuth(code: string) {  if (!code) {  return { error: "No authorization code provided" };  }  const postOptions = {  method: "POST",  headers: {  "Content-Type": "application/x-www-form-urlencoded",  },  body: new URLSearchParams({  client_id: id,  client_secret: auth,  grant_type: "authorization_code",  code: code,  redirect_uri: "http:   }),  };  try {     const discordResponse = await fetch("https:               const jsonResponse: IJsonResponse = await discordResponse.json();  if (!jsonResponse.access_token) {  return { error: "Access token is missing from the response" };  }  const token = jsonResponse.access_token;     const getUserOptions = {  method: "GET",  headers: {  "Content-Type": "application/json",  Authorization: `Bearer ${token}`,  },  };  const getUserResponse = await fetch("https:   if (!getUserResponse.ok) {  wrongAnswer(getUserResponse)  }  const jsonGetUserResponse: IUserResponse = await getUserResponse.json();  if (!jsonGetUserResponse.user) {  return { error: "User data is missing from the response" };  }  return { user: jsonGetUserResponse.user };  } catch (e) {     console.error("Error during Discord authentication process:", e);  return {  error: "An error occurred during the authentication process",  detail: e instanceof Error ? e.message : "Unknown error",  };  } } export function discordError(discordUserResponse: { error: any; status: any; detail: any; }) {  console.error("Discord Authentication Error:", discordUserResponse.error);     if (discordUserResponse.status) {  console.log("Status code:", discordUserResponse.status);  }  if (discordUserResponse.detail) {  console.log("Error details:", discordUserResponse.detail);  }     return {  error: discordUserResponse.error,  status: discordUserResponse.status || null,  detail: discordUserResponse.detail || null  }; }

// File: src/lib/sessionHandler.ts

  import { db } from '../hooks.server' import { ObjectId } from 'mongodb'; import type { UpdateResult } from 'mongodb'; import type { CookieSerializeOptions } from 'cookie'; export interface SessionData {  _id?: ObjectId;  sessionId: string;  stage?: string;  walletAddress?: string;  discord?: string | any;  twitter?: partialTwitter;  signedMessage?: string; } export interface partialTwitter {  userData: { data: { id: string, username: string, name: string } }  tokenResponse?: any; }   export async function updateSessionData(sessionId: string, data: Partial<SessionData>): Promise<UpdateResult<SessionData>> {  const database = db.collection<SessionData>('_sessions');  let updated = await database.updateOne(  { "sessionId": { $eq: sessionId } },  { $set: data },  { upsert: true }  );  return updated }   export async function getSessionData(sessionId: string): Promise<SessionData | null> {  const database = db.collection<SessionData>('_sessions');  let result = await database.findOne({ sessionId: sessionId }) as SessionData;  if (!result) return null  delete result._id  return result } class SessionId {  id: string;  constructor() {  this.id = this.generateSessionId();  }  private generateSessionId(): string {  return Math.random().toString(16).substring(2, 10);  } } export let cookieOptions: CookieSerializeOptions & { path: string } = {  httpOnly: true,    path: '/',    maxAge: 60 * 60 * 24 * 7,    sameSite: 'lax',    secure: false }; export async function createSession(cookies: { set: (arg0: string, arg1: string, arg2: CookieSerializeOptions & { path: string; }) => void; }) {  const session = new SessionId();  let sessionID = session.id;  let session_id;     cookies.set('sessionID', sessionID, cookieOptions);  let sessionUpdate = await updateSessionData(sessionID, { stage: "session-valid" })  if (sessionUpdate.upsertedId) session_id = sessionUpdate.upsertedId.toString()  cookies.set('session_id', session_id as string, cookieOptions)  return { sessionID } }

// File: src/lib/twitterAuth.ts

import { auth, Client } from "twitter-api-sdk"; import { TWITTER_KEY, TWITTER_SECRET } from '$env/static/private'; let twitter = {  key: TWITTER_KEY,  secret: TWITTER_SECRET, }; let twitterAuth = new auth.OAuth2User({  client_id: twitter.key,  client_secret: twitter.secret,  callback: "http:   scopes: ["users.read", "tweet.read"], }); export function getTwitterRedirectUrl(session: string) {  let authUrl  return authUrl = twitterAuth.generateAuthURL({  state: session,  code_challenge_method: "s256"  }) } export async function handleTwitterCallback(state: string, code: string, sessionID: string) {     if (state !== sessionID) {  throw new Error("Invalid state parameter");  }  try {     const tokenResponse = await twitterAuth.requestAccessToken(code);  console.log("Access token obtained:", tokenResponse);     const twitterClient = new Client(twitterAuth);     const userData = await twitterClient.users.findMyUser();  console.log("User data obtained:", userData);     return { userData, tokenResponse };  } catch (error) {  console.error("Error during Twitter callback handling:", error);  throw new Error("Failed to retrieve user data");  } }

// File: src/lib/wallet.ts

import { writable } from 'svelte/store'; import { getAccount, injected, type GetAccountReturnType } from '@wagmi/core' import {  connect,  reconnect,  disconnect as disconnectWagmi,  watchAccount } from '@wagmi/core' import { signMessage } from '@wagmi/core' import { config } from './config' type Wallet = GetAccountReturnType; const connectWallet = () => connect(config, { connector: injected() }); const disconnect = () => disconnectWagmi(config); const createWalletStore = () => {  const { set, subscribe, update } = writable<Wallet>(getAccount(config));  return {  subscribe,  set,  update,  connect: connectWallet,  disconnect: disconnect,  config  } }; export const walletStore = createWalletStore(); export { signMessage } from '@wagmi/core'   watchAccount(config, { onChange: walletStore.set });   reconnect(config);
